해싱이란 해시 함수(hash function)를 이용해서 데이터를 해시테이블(hash table)에 저장하고 검색 하는 기법을 말한다.

해시 함수는 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.

해싱을 구현한 컬렉션 클래스로는 HashSet, HashMap이 대표적이다. 해싱에서 사용하는 자료구조는 다음과 같이 배열과 링크드 리스트의 조합으로 되어 있다. 저장할 데이터의 키를 해시 함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ea204791-94b0-4594-95e9-37705edf8245/7235ae18-c1af-4126-877e-5ae32e8e3324/Untitled.png)

링크드 리스트는 검색에 불리한 자료구조이기 때문에 링크드 리스트의 크기가 커질수록 검색속도가 떨어지게 된다.

반면 배열은 배열의 크기가 커져도, 원하는 요소가 몇 번째에 있는 지만 알면 공식에 의해서 빠르게 원하는 값을 찾을 수 있다.

```java
배열의 인덱스가 n인 요소의 주소 = 배열의 시작주소 + type의 size * n
```

하나의 링크드 리스트에 최소한 데이터만 저장되려면, 저장될 데이터의 크기를 고려해서 HashMap의 크기를 적절하게 지정해주어야 하고, 해시 함수가 서로 다른 키에 대해서 중복된 해시 코드의 반환을 최소화해야 한다. 그래야 HasMap에서 빠른 검색 시간을 얻을 수 있다.

해싱을 구현하는 과정에서 제일 중요한 것은 해시 함수의 알고리즘이며, 해시 함수의 알고리즘은 주어진 키의 첫 번째 문자를 뽑아서 정수로 반환하기만 하면 된다.

```java
int hashFunction(String key){
	return Integer.parseInt(key.substring(0, 1);
}
```

실제로 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 Object에 정의된 hashCode( )를 해시 함수로 사용한다. Object클래스에 정의된 hashCode( )는 객체의 주소를 이용하는 알고리즘으로 해시 코드를 만들어 내기 때문에 모든 객체에 대해 hashCode( )를 호출한 결과가 서로 유일한 방법 이다.

String클래스의 경우 Oject로부터 상속 받은 hashCode( )를 오버라이딩해서 문자열의 내용으로 해시코드를 만들어 낸다. 그래서 서로 다른 String인스턴스일지라도 같은 내용의 문자열을 가졌다면 hashCode( )를 호출하였을 경우 같은 해시코드를 얻는다.

서로 다른 두 객체에 대해 equals( )로 비교한 결과가 true인 동시에 hashCode( )의 반환 값이 같아야 같은 객체로 인식한다. HashMap에서도 같은 방법으로 객체를 구별하며, 이미 존재하는 키에 대한 값을 저장하면 기존의 값을 새로운 값으로 덮어쓴다.

그래서 새로운 클래스를 정의할 때 equals( )를 재정의 오버라이딩해야 한다면 hashCode( )도 같이 재정의 해서 equlas( )의 결과가 ture인 두 객체의 해시코드 hashCode( )의 결과 값이 항상 같도록 해주어야 한다.

그렇지 않으면 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 equlas( )의 호출결과가 ture지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장할 것이다.